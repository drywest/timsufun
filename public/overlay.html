<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>YT Chat Overlay</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <style>
    html,body { height:100%; margin:0; background:transparent; }
    :root {
      --max-lines: 140;
    }
    #overlay {
      width:100%;
      height:100%;
      display:flex;
      align-items:flex-end;
      justify-content:flex-start;
      pointer-events:none; /* so clicks through in OBS */
      padding: 10px;
      box-sizing:border-box;
    }
    #chat {
      width: 100%;
      max-width: 1280px;
      display:flex;
      flex-direction:column-reverse; /* newest at bottom visually, but we'll insert at top for push-up style */
      gap:6px;
      overflow: hidden;
    }
    .message {
      display:flex;
      align-items:center;
      gap:10px;
      transform-origin:left bottom;
      will-change: transform, opacity;
      padding:6px 10px;
      border-radius:10px;
      backdrop-filter: blur(4px);
      background: rgba(0,0,0,0.15);
      color: #fff;
      font-weight:600;
      font-family: Inter, system-ui, -apple-system, Arial;
      box-shadow: 0 4px 10px rgba(0,0,0,0.25);
      opacity:0;
      transform: translateY(12px) scale(0.995);
    }
    .message.enter {
      animation: enter .12s linear forwards;
    }
    @keyframes enter {
      to { opacity:1; transform: translateY(0) scale(1); }
    }
    .username {
      font-weight:800;
      padding-right:8px;
      text-shadow: 0px 1px 0 rgba(0,0,0,0.5);
      flex: 0 0 auto;
      white-space:nowrap;
    }
    .text {
      font-weight:600;
      font-size:18px;
      line-height:1.05;
      color: #fff;
      display:flex;
      gap:6px;
      align-items:center;
      flex-wrap:wrap;
    }
    .avatar { width:34px; height:34px; border-radius:999px; overflow:hidden; flex:0 0 auto; }
    .avatar img { width:100%; height:100%; object-fit:cover; display:block; }
    img.emoji { height:22px; width:auto; vertical-align:middle; margin:0 2px; }
    /* keep overlay fast: limit number of DOM nodes */
    .message[data-index] { }
    /* small screen adjust */
    @media (max-width:600px) {
      .text { font-size:14px; }
      .username { font-size:14px; }
    }
  </style>
</head>
<body>
  <div id="overlay">
    <div id="chat" aria-live="polite"></div>
  </div>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    // overlay client
    (async function(){
      const socket = io({ transports: ['websocket'] });
      const chatEl = document.getElementById('chat');

      // parse videoId & freq from URL
      const u = new URL(location.href);
      // overlay path like /overlay/:videoId - extract last path segment
      const pathParts = location.pathname.split('/').filter(Boolean);
      const videoId = pathParts[pathParts.length - 1];
      const freq = parseInt(u.searchParams.get('freq')) || 700;
      const requestedFreq = Math.max(250, freq); // server enforces min 250ms too

      socket.on('connect', () => {
        console.log('socket connected', socket.id);
        socket.emit('subscribe', { videoId, freqMs: requestedFreq });
      });

      socket.on('chatBatch', (items) => {
        // items array [ {authorName, parts:[{type,text}|{type:'emoji',url,alt}], ...}, ... ]
        // We append each message and animate quickly
        for (const item of items) {
          appendMessage(item);
        }
        maintainLimit(140);
      });

      socket.on('error', (e) => console.error('server error', e));

      function maintainLimit(max) {
        const nodes = chatEl.querySelectorAll('.message');
        if (nodes.length > max) {
          // remove the oldest (bottom-most visually). We use column-reverse, so bottom is the first child
          for (let i = nodes.length - 1; i >= max; i--) {
            const node = nodes[i];
            if (node && node.parentNode) node.parentNode.removeChild(node);
          }
        }
      }

      function hashToHue(s) {
        // djb2
        let h = 5381;
        for (let i=0;i<s.length;i++){ h = ((h<<5)+h) + s.charCodeAt(i); h = h & 0xffffffff; }
        return Math.abs(h) % 360;
      }

      function usernameColor(nameOrId) {
        const hue = hashToHue(nameOrId || Math.random().toString());
        return `hsl(${hue} 92% 52%)`; // very saturated, vibrant
      }

      function appendMessage(item) {
        const wrapper = document.createElement('div');
        wrapper.className = 'message';
        wrapper.setAttribute('data-id', item.id || '');
        // avatar
        if (item.authorPhoto) {
          const av = document.createElement('div'); av.className = 'avatar';
          const img = document.createElement('img'); img.src = item.authorPhoto; img.alt = item.authorName || '';
          av.appendChild(img);
          wrapper.appendChild(av);
        }
        const name = document.createElement('div');
        name.className = 'username';
        name.style.color = usernameColor(item.authorChannelId || item.authorName);
        name.innerText = item.authorName || 'Unknown';
        wrapper.appendChild(name);

        const text = document.createElement('div');
        text.className = 'text';
        // build message parts
        if (Array.isArray(item.parts)) {
          for (const p of item.parts) {
            if (p.type === 'text') {
              const tspan = document.createElement('span');
              tspan.innerText = p.text;
              text.appendChild(tspan);
            } else if (p.type === 'emoji') {
              if (p.url) {
                const im = document.createElement('img');
                im.className = 'emoji';
                im.src = p.url;
                im.alt = p.alt || '';
                im.referrerPolicy = 'no-referrer';
                text.appendChild(im);
              } else {
                const alt = document.createElement('span');
                alt.innerText = p.alt || '';
                text.appendChild(alt);
              }
            } else {
              const fallback = document.createElement('span');
              fallback.innerText = p.text || JSON.stringify(p);
              text.appendChild(fallback);
            }
          }
        }
        wrapper.appendChild(text);
        // Insert at top to create push-up effect (using column-reverse)
        chatEl.insertBefore(wrapper, chatEl.firstChild);
        // trigger animation
        requestAnimationFrame(() => {
          wrapper.classList.add('enter');
        });
      }
    })();
  </script>
</body>
</html>
